# 客户端与服务端

::: tip 阅读本文大概需要 9 分钟。

口袋方舟编辑器的一大核心功能就是可以让开发者快速便捷的制作一款多人游戏，那么既然是多人游戏，首先要了解一下什么是客户端，什么是服务端。

:::

<iframe sandbox="allow-scripts allow-downloads allow-same-origin allow-popups allow-presentation allow-forms" frameborder="0" draggable="false" allowfullscreen="" allow="encrypted-media;" referrerpolicy="" aha-samesite="" class="iframe-loaded" src="//player.bilibili.com/player.html?aid=322817180&bvid=BV1qw411q7ba&cid=1317943485&p=20&autoplay=0" style="border-radius: 7px; width: 100%; height: 360px;"></iframe>

关于本章节更多内容可以查阅产品手册：[网络同步原理和结构 | 产品手册 (ark.online)](https://docs.ark.online/Scripting/NetworkSynchronizationStructureandMechanics.html)

## 1. 客户端与服务端的关系

![d2797cf2-6ba5-48eb-9efb-734fa62ea186](https://arkimg.ark.online/d2797cf2-6ba5-48eb-9efb-734fa62ea186.webp)

在口袋方舟中，我们使用了 C/S 网络模型也就是客户端/服务端模型，游戏发布后服务端代码将会运行在口袋方舟官方提供的服务器中，客户端代码运行在用户的设备中。

当用户加入某个游戏后，他的设备将会作为**客户端**自动连接至服务器中，玩家进入到游戏时在口袋方舟官方服务器中就会启动一个服务端，该服务端能容纳的玩家数量可以在编辑器中设置。后序进入游戏的玩家会优先进入到已经启动的服务端中，当服务端人数已满，服务器就会创建一个新的服务端供后续玩家进入。

连接建立后服务端会自动与客户端同步游戏信息，并且提供了多种与客户端相互通讯的手段。

## 2. 客户端与服务端常见的通讯方式

### 2.1 单个客户端给服务器发送信息

![963725fc-e27b-4009-b7c1-c0ddf85381a9](https://arkimg.ark.online/963725fc-e27b-4009-b7c1-c0ddf85381a9.webp)

从某个客户端发送消息给服务端。例如在游戏中某个玩家与 NPC 购买了一件道具，需要发送购买的信息给服务端。服务端会根据玩家选定的道具执行响应逻辑，如判断金币是否足以购买、购买成功后发送道具到玩家存档等。 

### 2.2 服务端给单个客户端发送信息

![48e9c73c-a04c-4ecf-ac46-369f065a01cf](https://arkimg.ark.online/48e9c73c-a04c-4ecf-ac46-369f065a01cf.webp)

从服务端发送消息到某个指定客户端。例如玩家掉进了陷阱中，服务端会给它下发消息通知它的客户端逻辑需要表现出掉血的样子，如修改血条 UI 的数值、播放受伤的音效等。

### 2.3 服务端给全体客户端发送消息

![52c590b4-36cc-4195-a0b7-f3cac5836df7](https://arkimg.ark.online/52c590b4-36cc-4195-a0b7-f3cac5836df7.webp)

服务端向所有客户端发送消息，这种发送方式我们也称之为服务端广播。例如在游戏中服务端向所有玩家同步游戏当前的状态，如游戏开始倒计时、获胜者队伍信息等。

更多网络相关查看产品文档：[网络同步原理和结构](https://docs.ark.online/Scripting/NetworkSynchronizationStructureandMechanics.html)

## 3. 游戏对象的网络状态

口袋方舟中，我们创建的每个游戏物体(包括脚本)，都有三种网络状态，第一种是纯客户端运行，第二种是纯服务端运行，第三种是客户端和服务端运行，要注意的是脚本也是拥有网络状态的，与美术对象不同的是脚本的网络状态代表着它其中代码的运行环境，这里使用表格列出它们的区别。

|              | 客户端 <Badge type="tip" text="Client" /> | 服务端 <Badge type="warning" text="Server" /> | 客户端和服务端 <Badge type="danger" text="Client&Server" />  |
| ------------ | ----------------------------------------- | :-------------------------------------------- | ------------------------------------------------------------ |
| 在客户端显示 | ✔                                         | ❌                                             | ✔                                                            |
| 在服务端显示 | ❌                                         | ✔                                             | ✔                                                            |
| 在客户端控制 | ✔                                         | ❌                                             | ✔                                                            |
| 在服务端控制 | ❌                                         | ✔                                             | ✔                                                            |
| 生成方式     | 客户端生成，服务端没有该物体              | 服务端生成，客户端没有该物体                  | 服务端生成对象然后同步给客户端，客户端根据同步来的数据再生成这个对象 |
| 同步方式     | 修改不会自动同步给其它客户端              | 修改会同步给所有客户端                        | 修改会同步给所有客户端                                       |

### 3.1. 服务端 Server

在服务端中没有可视化的内容，是由纯数据与逻辑构成的。服务端处理完数据后将会同步给客户端，客户端根据服务端发来的数据做可视化的渲染。

对于脚本来说，如果需要调用**数据存储**接口就需要让脚本在服务端执行，可以将它的网络状态设置为服务端。

当我们将一个美术对象设置为服务端时，它是没有意义的，因为服务端不会渲染画面，且单服务端也不会向客户端同步数据。

### 3.2. 客户端 Client

在客户端中，会根据服务端下发的数据来渲染游戏场景，除此之外还承担着接收玩家输入信息的责任，比如玩家使用了某些道具、点击了 UI 等操作，客户端经过一定的预处理之后发送给服务器。

对于脚本来说与 UI 相关的功能，都需要放在客户端执行。

### 3.3.双端 Server & Client

双端，顾名思义客户端和服务端都会存在。但是它在客户端的对象会与服务端的对象保持同步，在服务端对它进行的修改都会自动同步到所有客户端中。比如一个双端正方体模型，我们在服务端修改了它的大小或位置，所有客户端中正方体的也会同步为与服务端一致。

比如我们在服务端修改一个方块的大小，修改完毕后服务端会通知所有客户端该方块的最新大小，客户端搜到消息后自动设置为服务端的大小。

可以将双端物体的客户端部分想象为镜子中的物体，服务端物体的修改会自动同步给客户端的物体。

![635823dc-f86a-4193-9ae4-f740596eccab](https://arkimg.ark.online/635823dc-f86a-4193-9ae4-f740596eccab.webp)
